// <auto-generated>
// Most of the contents of this file are just simple P/Invoke signatures from
// pinvoke.net and MSDN, we'll count this as auto-generated to make StyleCop
// shut up about all the "grammatical errors".
// </auto-generated>

//---------------------------------------------------------------------------------------
// <copyright file="Kernel32.cs" company="SharpBlade">
//     Copyright (c) 2014 by Adam Hellberg and Brandon Scott.
//
//     Permission is hereby granted, free of charge, to any person obtaining a copy of
//     this software and associated documentation files (the "Software"), to deal in
//     the Software without restriction, including without limitation the rights to
//     use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//     of the Software, and to permit persons to whom the Software is furnished to do
//     so, subject to the following conditions:
//
//     The above copyright notice and this permission notice shall be included in all
//     copies or substantial portions of the Software.
//
//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//     Disclaimer: SharpBlade is in no way affiliated
//     with Razer and/or any of its employees and/or licensors.
//     Adam Hellberg does not take responsibility for any harm caused, direct
//     or indirect, to any Razer peripherals via the use of SharpBlade.
//
//     "Razer" is a trademark of Razer USA Ltd.
// </copyright>
//---------------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;

namespace Sharparam.SharpBlade.Native.WinAPI
{
    /// <summary>
    /// Static class containing all functions
    /// provided by the Windows Kernel32 library.
    /// </summary>
    public static class Kernel32
    {
        /// <summary>
        /// The standard input device. Initially, this is the console input buffer, CONIN$.
        /// </summary>
        public const int STD_INPUT_HANDLE = -10;

        /// <summary>
        /// The standard output device. Initially, this is the active console screen buffer, CONOUT$.
        /// </summary>
        public const int STD_OUTPUT_HANDLE = -11;

        /// <summary>
        /// The standard error device. Initially, this is the active console screen buffer, CONOUT$.
        /// </summary>
        public const int STD_ERROR_HANDLE = -12;

        /// <summary>
        /// The code page recommended for consoles spawned with <see cref="NativeMethods.AllocConsole" />.
        /// </summary>
        public const int CODE_PAGE = 437;

        internal static class NativeMethods
        {
            /// <summary>
            /// DLL file to import functions from.
            /// </summary>
            private const string DllName = "kernel32.dll";

            /// <summary>
            /// Retrieves a handle to the specified standard device (standard input, standard output, or standard error).
            /// </summary>
            /// <param name="nStdHandle">The standard device.</param>
            /// <returns>
            /// If the function succeeds, the return value is a handle to the specified device,
            /// or a redirected handle set by a previous call to SetStdHandle.
            /// The handle has GENERIC_READ and GENERIC_WRITE access rights,
            /// unless the application has used SetStdHandle to set a standard handle with lesser access.
            /// If the function fails, the return value is INVALID_HANDLE_VALUE.
            /// To get extended error information, call GetLastError.
            /// If an application does not have associated standard handles,
            /// such as a service running on an interactive desktop,
            /// and has not redirected them, the return value is NULL.
            /// </returns>
            [DllImport(DllName, EntryPoint = "GetStdHandle", SetLastError = true, CharSet = CharSet.Auto,
                CallingConvention = CallingConvention.StdCall)]
            internal static extern IntPtr GetStdHandle(int nStdHandle);

            /// <summary>
            /// Allocates a new console for the calling process.
            /// </summary>
            /// <returns>
            /// If the function succeeds, the return value is nonzero (true).
            /// If the function fails, the return value is zero (false).
            /// To get extended error information, call GetLastError.
            /// </returns>
            /// <remarks>
            /// A process can be associated with only one console,
            /// so the AllocConsole function fails if the calling process already has a console.
            /// A process can use the FreeConsole function to detach itself from its current console,
            /// then it can call AllocConsole to create a new console or AttachConsole to attach to another console.
            /// If the calling process creates a child process, the child inherits the new console.
            /// AllocConsole initializes standard input, standard output,
            /// and standard error handles for the new console.
            /// The standard input handle is a handle to the console's input buffer,
            /// and the standard output and standard error handles are handles to the console's screen buffer.
            /// To retrieve these handles, use the GetStdHandle function.
            /// This function is primarily used by graphical user interface (GUI) application to create a console window.
            /// GUI applications are initialized without a console. Console applications are initialized with a console,
            /// unless they are created as detached processes (by calling the CreateProcess function with the DETACHED_PROCESS flag).
            /// </remarks>
            [DllImport(DllName, EntryPoint = "AllocConsole", SetLastError = true, CharSet = CharSet.Auto,
                CallingConvention = CallingConvention.StdCall)]
            internal static extern bool AllocConsole();

            /// <summary>
            /// Detaches the calling process from its console.
            /// </summary>
            /// <returns>
            /// If the function succeeds, the return value is nonzero (true).
            /// If the function fails, the return value is zero (false).
            /// To get extended error information, call GetLastError.
            /// </returns>
            /// <remarks>
            /// A process can be attached to at most one console.
            /// If the calling process is not already attached to a console,
            /// the error code returned is ERROR_INVALID_PARAMETER (87).
            /// A process can use the FreeConsole function to detach itself from its console.
            /// If other processes share the console, the console is not destroyed,
            /// but the process that called FreeConsole cannot refer to it.
            /// A console is closed when the last process attached to it terminates or calls FreeConsole.
            /// After a process calls FreeConsole,
            /// it can call the AllocConsole function to create a new console or AttachConsole to attach to another console.
            /// </remarks>
            [DllImport(DllName, EntryPoint = "FreeConsole", SetLastError = true, CharSet = CharSet.Auto,
                CallingConvention = CallingConvention.StdCall)]
            internal static extern int FreeConsole();
        }
    }
}
